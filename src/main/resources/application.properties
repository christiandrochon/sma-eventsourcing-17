#spring.application.name=sma-monolithe-${spring.profiles.active}
spring.application.name=sma-monolithe

#spring.profiles.group.production=gui, command, query
#server.port=8081
server.port=8092
#external.service.url=http://localhost:8091
external.service.url=http://thymeleaf-frontend:8091

spring.thymeleaf.cache=false
#spring.config.import=optional:configserver:${CONFIG_SERVICE_URL:http://localhost:9999}
#eureka.client.service-url.defaultZone=${DISCOVERY_SERVICE_URL:http://localhost:8761/eureka}

# Avec docker compose, et la conf recuperee depuis github, ca fonctionne, peu importe le profile, et fonctionne meme sans profile tout court!
#spring.profiles.active=prod


################### POSTGRESQL

#spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST:localhost}:${POSTGRES_PORT:5432}/${POSTGRES_DB:monolithe}
spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST:postgres-monolithe}:${POSTGRES_PORT:5432}/${POSTGRES_DB:monolithe}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
################### COMMUN
spring.datasource.username=${POSTGRES_USER:postgres}
spring.datasource.password=${POSTGRES_PASSWORD:password}


spring.jpa.show-sql = true
spring.jpa.hibernate.ddl-auto=update
#spring.jpa.hibernate.ddl-auto=create-drop



#resilience4j.retry.instances.retryApi.max-attempts=3
#resilience4j.retry.instances.retryApi.wait-duration=1s
#resilience4j.retry.metrics.legacy.enabled=true
#resilience4j.retry.metrics.enabled=true


###########################################
#   AXON
# https://docs.axoniq.io/reference-guide/v/3.3/part-iv-advanced-tuning/advanced-customizations#serializers
axon.serializer.general=jackson
#axon.serializer.events=jackson
#axon.serializer.messages=jackson



#management.endpoint.health.show-details=always
#management.endpoints.web.exposure.include=*
#
#logging.level.io.axoniq.demo=debug
#axoniq.axonserver.keep-alive-time=0
#axoniq.axonserver.keep-alive-timeout=604800000
#axoniq.axonserver.min-keep-alive-time=604800000

# We look for Axon Server locally, unless we find a PCF Binding for AxonServer
#axon.axonserver.servers=${vcap.services.AxonServer.credentials.uri:localhost}
#axon.axonserver.servers=localhost:8124
#axoniq.axonserver.standalone=true

# Axon configuration to use the RDBMS as Event Store
#axon.eventhandling.processors.garagequery-summary.mode=tracking
#axon.eventhandling.processors.garagequery-summary.source=eventStore

#axon.eventhandling.processors.garagequery-summary.mode=subscribing
#axon.eventhandling.processors.garagequery-summary.source=eventBus

#spring.jpa.properties.hibernate.id.db_structure_naming_strategy=legacy
## Required to enabled the DistributedCommandBus
#axon.distributed.enabled=true
## Defines the load factor used for this segment. Defaults to 100
#axon.distributed.load-factor=100
## Defines the CapabilityDiscoveryMode used. Defaults to REST
#axon.distributed.spring-cloud.mode=rest
### Defines the endpoint used to retrieve member capabilities from. Defaults to "/member-capabilities"
##axon.distributed.spring-cloud.rest-mode-url="/my-custom-endpoint"
## Defines whether the CapabilityDiscoveryMode should be decorated to ignore faulty ServiceInstances
#axon.distributed.spring-cloud.enable-ignore-listing=true
## Defines whether the CapabilityDiscoveryMode should be decorated to accept all types of commands
#axon.distributed.spring-cloud.enable-accept-all-commands=true


